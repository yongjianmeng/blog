# MongoDB索引调优 #

通过建立MongoDB的索引能加快查询速度，因为有了索引我们就能避免全表扫描，并能够通过索引快速定位到符合索引条件的文档，并在此基础上做其他的操作（过滤、排序等）。

那么，我们是不是就可以认为，通过建立索引就能百分之百地保证提高查询速度呢？索引有没有其他副作用呢？如何正确且高效地建立索引呢？这里，我将列出几个我在最近的实践中碰到的建立索引的**建议**，希望对各位有帮助。 

## 建立组合索引的几点建议 ##

组合索引（Compound Index）是我们在MongoDB经常使用的一种索引，例如：
```
db.User.ensureIndex({
  age: -1,
  userName: 1
}, {
  background: true,
  name: "user_index_by_age_and_userName"
})
```

上述语句在User集合上的age和userName字段建立了索引，其中在age字段上是建立降序索引，而在userName字段上是建立升序索引，background表示其在后台建立索引，这样在建立索引的时候就不会锁住整个MongoDB（只会锁住建立索引的会话而不是整个数据库，如果整个数据库被锁住将导致其他客户端访问MongoDB被阻塞住），name指定了该索引的名称。

### 索引字段的顺序很重要 ###

**组合索引是有顺序的**。在上述例子中，我们在age字段和userName字段上建立索引，如果某个查询使用了该索引，它会在索引树（B树索引）上先通过age字段查找索引，再通过userName字段查找索引。我们知道，正常情况下，age字段的范围是从1~100，大约有100种情况，而userName可以有非常多种情况，如果不允许重复，那么每个用户都有一个唯一的userName。
假如User集合有1000w条数据，年龄分布均匀，我们要执行以下查询语句：
```
db.User.find({
  age: { $gt: 10 },
  userName: 'Jonas'
})
```
- 如果先通过age字段再按照userName字段建立索引，那么在搜索索引树时，需要先确定age字段的范围在其中90%的范围内，再在这90%的范围内通过树搜索userName字段为Jonas的索引。
- 如果先通过userName字段再按照age字段建立索引，那么在搜索索引树时，需要先确定userName字段的值，这样基本上可以直接找出对应的索引，搜索范围就为 0.00001%，然后再判断该索引的age字段是否满足条件。

可以用下面这张图解释：
![](https://github.com/yongjianmeng/blog/blob/master/images/MongoDB%E7%B4%A2%E5%BC%95%E8%B0%83%E4%BC%98-0.png)

其中A、B、C分别表示每个搜索条件单独过滤后的索引数量，第一种情况下，先过滤A，再过滤B，最后过滤C，那么后续几种都需要在大量的索引上搜索。而第二种情况先过滤C，再过滤B，最后过滤A，虽然最终结果是一样的，但第一步之后的后续几步都只要在少量的索引上搜索，大大提高了效率。

> $and 语句中我们也能用这种方式。先通过一个索引来搜索出少量的文档，再在这些少量文档中做过滤。

通过userName字段再按照age字段建立索引的语句如下：
```
db.User.ensureIndex({
  userName: 1,
  age: -1
}, {
  background: true,
  name: "user_index_by_userName_and_age"
})
```

### 尽量减少索引字段 ###
建立组合索引的字段越多，索引所占用的空间也就越多，如果内存空间不够载入所有的索引，那么MongoDB就会将其放入磁盘中，用到的时候才会从磁盘中载入，这时候就多了磁盘IO操作，效率大大地降低。因此我们在建立组合索引的时候需要慎重考虑，有些字段是否真的需要放入组合索引中。

查看索引占用的空间大小的语句：
```
db.User.stats().indexSizes
```

## 降低索引大小的几点建议 ##
随着数据库数据量的增长，索引所占用的空间也会越来越多，当总索引大小超过可用的内存空间时，就会被MongoDB放入磁盘中，用到的时候才会从磁盘中载入内存，从而多了磁盘IO操作，大大地降低了效率，因此我们需要通过一些方式降低索引的大小。

### 移除不常用/不用的索引 ###
通过以下语句可以查看集合上每一个索引被用到的次数：
```
db.User.aggregate([ { $indexStats: {} } ])
```

```
{ 
    "name" : "_id_",  --------------------------------------> 索引名
    "key" : {  ---------------------------------------------> 索引包含的字段
        "_id" : NumberInt(1)
    }, 
    "host" : "LAPTOP-UN65HSDR:27017", 
    "accesses" : {
        "ops" : NumberLong(9),  ----------------------------> 索引被用到的次数
        "since" : ISODate("2018-09-12T13:05:56.248+0000") --> 统计开始的时间
    }
}
{ 
    "name" : "user_index_by_age_and_userName", 
    "key" : {
        "age" : -1.0, 
        "userName" : 1.0
    }, 
    "host" : "LAPTOP-UN65HSDR:27017", 
    "accesses" : {
        "ops" : NumberLong(10), 
        "since" : ISODate("2018-09-12T13:15:41.524+0000")
    }
}
{ 
    "name" : "title_1", 
    "key" : {
        "title" : 1.0
    }, 
    "host" : "LAPTOP-UN65HSDR:27017", 
    "accesses" : {
        "ops" : NumberLong(0), 
        "since" : ISODate("2018-09-12T13:05:56.248+0000")
    }
}


```
通过上述的查询结果我们可以判断出一些索引不常用或从来没用过，从而可以移除这些索引。例如上述例子中，我们看到 title_1 索引我们从来没用过，所以我们可以尝试删除它。
> 注意，这里统计的次数是从上次开启MongoDB Server开始统计的，不是从建立数据库开始的，所以不能单纯地以此为依据删除索引，还需要从应用程序的角度去判断。

### 移除重复的索引 ###
假设现在User表上有以下索引：
```
[
    {
        "v" : 2.0, 
        "key" : {
            "_id" : 1.0
        }, 
        "name" : "_id_", 
        "ns" : "test.User"
    },
    {
        "v" : 2.0, 
        "key" : {
            "age" : -1.0, 
            "userName" : 1.0
        }, 
        "name" : "user_index_by_age_and_userName", 
        "ns" : "test.User", 
        "background" : true
    }, 
    {
        "v" : 2.0, 
        "key" : {
            "age" : -1.0
        }, 
        "name" : "user_index_by_age", 
        "ns" : "test.User", 
        "background" : true
    }
]
```
我们知道，组合索引有包含前缀的特性，例如我们在 **{ a: 1, b: 1, c: 1 }** 上建立了索引，那么其实也相当于同时在 **{ a: 1 }** 以及 **{ a: 1, b: 1 }** 上建立了索引，索引后面两个索引是重复索引。在User表上，索引 **user_index_by_age** 被包含在 **user_index_by_age_and_userName** 中，因此 **user_index_by_age** 是重复索引，我们可以把它删除掉以节约空间。

> 注意，{ b: 1, c: 1 }、 { c: 1 }、 { a: 1, b: -1 } 不是 { a: 1, b: 1, c: 1 } 前缀，因此不属于重复索引。

### 使用部分索引 ###

我们还能通过建立部分索引来降低索引的大小。那么，什么是部分索引呢？

举个例子，假如我们不需要在所有的age字段范围内建立索引，而只需要在age字段大于18且小于60的范围内建立索引，那么我们就可以只为在此范围内（18 < age < 60）的数据建立索引，而不需要为在该范围外（0 < age <= 18 或 age >= 60）的数据建立索引。

```
db.User.ensureIndex({
  userName: 1
}, {
  background: true,
  name: "user_index_by_userName_and_age_between_18_and_60",
  partialFilterExpression: {
    age: {
      $gt: 18,
      $lt: 60
    }
  }
})
```
假设age字段分布均匀，那么大约能节省60%的空间。

> 注意，部分索引的partialFilterExpression有条件限制，只能在以下表达式上建立：
> 1. equality 表达式 (例如： field: value 或者使用 $eq 操作符),
> 2. $exists: true，注意这里只能为true, 笔者曾经尝试在false上建立，会报错！！！
> 3. $gt, $gte, $lt, $lte 表达式。
> 4. $type 表达式。
> 5. $and 操作符只能在最外层操作，不能嵌套。 

### 减小集合的大小 ###

数据量大是索引占用空间增大最直接的原因，因此我们可以通过备份老旧数据（把旧数据放入历史数据库中），或者通过分片的方式来减少单个集合的大小，集合减小了，其对应的索引的大小也会减小。

## 不是所有的查询都适合使用索引 ##
**并不是所有的查询都可以用索引**。如果某个查询需要在1000w条数据中返回其中的90%的数据而不是只获取一些数据，那么这个查询就不应该使用索引。

如果对这个查询使用了索引，结果就是几乎遍历了整个索引树，如果这个索引树占用的空间很多，例如50G，而搜索结果占用的空间为200G，总占用空间为250G，这还不如不使用索引，不适用索引只需要占用200G的空间。

**所以，索引一般用在返回结果只是总体数据的一小部分的时候，根据经验，一旦要大约返回集合一半的数据就不要使用索引了。**

如果需要避免在查询时使用索引，可以使用自然排序（按照磁盘上的存储顺序返回数据）的方式禁用索引：

```
db.User.find({
  age: { $gt: 10 }
}).sort({ $natural: 1 })
```

这个查询会走全表扫描（COLLSCAN），而不是使用age字段的索引。

## 总结 ##
通过大量的实践能得出很多种优化的方式，但不会有一种建立索引的**银弹**，需要大家根据不同的环境与业务来建立/优化索引，有问题欢迎提交 PR 讨论。

> 欢迎转载，注明出处即可。